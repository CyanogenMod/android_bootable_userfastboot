/*
 * Copyright (c) 2009, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *  * Neither the name of Google, Inc. nor the names of its contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <errno.h>
#include <fcntl.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <inttypes.h>
#include <linux/input.h>
#include <sys/utsname.h>

#include <cutils/android_reboot.h>
#include <cutils/hashmap.h>
#include <cutils/properties.h>

/* from ext4_utils for sparse ext4 images */
#include <sparse_format.h>
#include <sparse/sparse.h>
#include <efivar.h>

#include <bootloader.h>
#include "aboot.h"
#include "fastboot.h"
#include "userfastboot.h"
#include "userfastboot_util.h"
#include "userfastboot_plugin.h"
#include "userfastboot_ui.h"
#include "gpt.h"
#include "network.h"
#include "sanity.h"

/* Generated by the makefile, this function defines the
 * register_userfastboot_plugins() function, which calls all the
 * registration functions for device-specific extensions. */
#include "register.inc"

#define CMD_SHOWTEXT		"showtext"
#define CMD_HIDETEXT		"hidetext"
#define CMD_LOCK		"lock"
#define CMD_UNLOCK		"unlock"
#define CMD_UNLOCK_NOCONFIRM	"unlock-noconfirm"

#define FASTBOOT_GUID \
	EFI_GUID(0x1ac80a82, 0x4f0c, 0x456b, 0x9a99, 0xde, 0xbe, 0xb4, 0x31, 0xfc, 0xc1);
#define OEM_LOCK_VAR		"OEMLock"

#define EFI_GLOBAL_VARIABLE \
	EFI_GUID(0x8BE4DF61, 0x93CA, 0x11d2, 0xAA0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C);
#define SECURE_BOOT_VAR		"SecureBoot"

struct flash_target {
	char *name;
	Hashmap *params;
};

Hashmap *flash_cmds;
Hashmap *oem_cmds;

/*

Unlockable Android devices must securely erase all user data prior to being
unlocked. The failure to properly delete all data on unlocking may allow a
physically proximate attacker to gain unauthorized access to confidential
Android user data. We?ve seen numerous instances where device manufacturers
improperly implemented unlocking. This e-mail describes best practices for
implementing the unlock data wipe requirement.

Details

Many Android devices support unlocking. This allows the device owner to modify
the system partition and/or install a custom operating system. Common use cases
for this include installing a third-party ROM, and/or doing systems level
development on the device.

For example, on Google Nexus devices, an end user can run ?fastboot oem unlock?
to start the unlocking process. When an end user runs this command, the
following message is displayed:

Unlock bootloader?

If you unlock the bootloader, you will be able to install custom operating
system software on this phone.

A custom OS is not subject to the same testing as the original OS, and can
cause your phone and installed applications to stop working properly.

To prevent unauthorized access to your personal data, unlocking the bootloader
will also delete all personal data from your phone (a ?factory data reset?).

Press the Volume Up/Down buttons to select Yes or No. Then press the Power
button to continue.

Yes: Unlock bootloader (may void warranty) No: Do not unlock bootloader and
restart phone.

A device which is unlocked may be subsequently relocked, by issuing the
?fastboot oem lock? command. Locking the bootloader provides the same
protection of user data with the new custom OS as was available with the
original OEM OS. e.g. user data will be wiped if the device is unlocked again
in the future

To prevent the disclosure of user data, a device which supports unlocking needs
to implement it properly. We?ve seen multiple public vulnerability reports
describing flaws in the unlocking process, including:

https://plus.sandbox.google.com/117003401706323264508/posts/7jYeE7NUbzi
http://forum.xda-developers.com/showthread.php?t=2266928

A properly implemented unlocking process will have the following properties:

1. When the unlocking command is confirmed by the user, the device MUST start
an immediate data wipe. The ?unlocked? flag MUST NOT be set until after the
secure deletion is complete.

2. If a secure deletion cannot be completed, the device MUST stay in a locked
state.

3. If supported by the underlying block device, ?ioctl(BLKSECDISCARD)? or
equivalent SHOULD be used. For eMMC devices, this means using a Secure Erase or
Secure Trim command. For eMMC 4.5 and later, this means doing a normal Erase or
Trim followed by a Sanitize operation.

4. If BLKSECDISCARD is NOT supported by the underlying block device,
?ioctl(BLKDISCARD)? MUST be used instead. On eMMC devices, this is a normal
Trim operation.

5. If BLKDISCARD is NOT supported, overwriting the block devices with all zeros
is acceptable.

6. An end user MUST have the option to require that user data be wiped prior to
flashing a partition. For example, on Nexus devices, this is done via the
"fastboot oem lock" command.

7. A device MAY record, via efuses or similar mechanism, whether a device was
unlocked and/or relocked.

These requirements ensure that all data is destroyed upon the completion of an
unlock operation. Failure to implement these protections is considered a
?moderate? level security vulnerability.

For additional questions or concerns, please feel free to contact
security@android.com<security@android.com>.

*/

static bool is_loader_locked(void)
{
	int ret;
	uint32_t attributes;
	char *data;
	size_t dsize;
	efi_guid_t fastboot_guid = FASTBOOT_GUID;

	ret = efi_get_variable(fastboot_guid, OEM_LOCK_VAR, (uint8_t **)&data,
			&dsize, &attributes);
	if (ret) {
		pr_debug("Couldn't read OEMLock\n");
		return true;
	}

	if (dsize < 2 || data[1]) {
		pr_debug("Malformed OEMLock data\n");
		return true;
	}

	if (!strcmp(data, "0"))
		return false;
	return true;
}


static bool is_secure_boot_enabled(void)
{
	int ret;
	uint32_t attributes;
	char *data;
	size_t dsize;
	efi_guid_t global_guid = EFI_GLOBAL_VARIABLE;

	ret = efi_get_variable(global_guid, SECURE_BOOT_VAR, (uint8_t **)&data,
			&dsize, &attributes);
	if (ret) {
		pr_debug("Couldn't read SecureBootk\n");
		return false;
	}

	if (!dsize)
		return false;

	if (data[0] == 1)
		return true;

	return false;
}


static bool confirm_oem_unlock(void)
{
	int chosen_item = -1;
	int selected = 1;
	bool result = false;

	char *headers[] = {
		"**** Unlock bootloader? ****",
		"",
		"If you unlock the bootloader, you will be able to install custom operating",
		"system software on this device. A custom OS is not subject to the same",
		"testing as the original OS, and can cause your device and installed",
		"applications to stop working properly. To prevent unauthorized access to your",
		"personal data, unlocking the bootloader will also delete all personal data",
		"from your device (a 'factory data reset').",
		"",
		"Press the Volume Up/Down to select Yes or No. Then press the Power button.",
		"",
		NULL };

	char *items[] = {
		"Yes: Unlock bootloader",
		"No: Do not unlock bootloader",
		NULL };

	mui_clear_key_queue();
	mui_start_menu(headers, items, selected);

	while (chosen_item < 0) {
		int key = mui_wait_key();

		pr_debug("got key event %d\n", key);
		switch (key) {
		case -1:
			pr_info("OEM unlock prompt timed out\n");
			goto out;

		case KEY_UP:
		case KEY_VOLUMEUP:
			--selected;
			selected = mui_menu_select(selected);
			break;

		case KEY_DOWN:
		case KEY_VOLUMEDOWN:
			++selected;
			selected = mui_menu_select(selected);
			break;

		case KEY_POWER:
		case KEY_ENTER:
			if (selected == 0)
				result = true;
			goto out;
		}
	}
out:
	mui_end_menu();
	return result;
}


static int set_loader_lock(bool state, bool skip_confirmation)
{
	efi_guid_t fastboot_guid = FASTBOOT_GUID;
	int ret;
	char *data;
	bool wiped = false;

	data = state ? "1" : "0";

	if (state == false) {
		/* Must securely erase user data before unlocking */
		struct fstab_rec *vol = volume_for_name("data");
		if (vol == NULL) {
			pr_error("invalid fstab\n");
			return -1;
		}
		/* Check to make sure the data partition device node
		 * actually exists. If it doesn't the disk is unpartitioned
		 * and we can proceed */
		if (is_valid_blkdev(vol->blk_device)) {
			if (!skip_confirmation && !confirm_oem_unlock())
				return -1;

			pr_status("Userdata erase required, this can take a while...\n");
			wiped = true;
			if (erase_partition(vol)) {
				pr_error("couldn't erase data partition\n");
				return -1;
			}
		}
	}

	ret = efi_set_variable(fastboot_guid, OEM_LOCK_VAR,
			(uint8_t *)data, 2,
			EFI_VARIABLE_NON_VOLATILE |
			EFI_VARIABLE_RUNTIME_ACCESS |
			EFI_VARIABLE_BOOTSERVICE_ACCESS);
	if (ret) {
		pr_error("Coudn't set OEMLock\n");
		return -1;
	}

	if (state == false) {
		if (!is_loader_locked()) {
			pr_info("Fastboot now unlocked\n");
			if (wiped) {
				fastboot_info("Rebooting to wipe RAM contents");
				fastboot_okay("");
				android_reboot(ANDROID_RB_RESTART2, 0, "fastboot");
			}
			fastboot_publish("unlocked", "yes");
		} else {
			pr_error("Inconsistent OEMLock state!!\n");
			return -1;
		}
	} else {
		if (is_loader_locked()) {
			pr_info("Fastboot now locked\n");
			fastboot_publish("unlocked", "no");
		} else {
			pr_error("Inconsistent OEMLock state!!\n");
			return -1;
		}
	}
	populate_status_info();
	return 0;
}


static bool strcompare(void *keyA, void *keyB)
{
	return !strcmp(keyA, keyB);
}

static int strhash(void *key)
{
	return hashmapHash(key, strlen((char *)key));
}

static void process_target(char *targetspec, struct flash_target *tgt)
{
	char *params;
	char *paramtoken;
	char *saveptr;
	int no_params = 0;

	params = strchr(targetspec, ':');
	if (!params)
		no_params = 1;
	else {
		*params = '\0';
		params++;
	}

	tgt->name = targetspec;
	pr_verbose("target name: %s\n", targetspec);

	tgt->params = hashmapCreate(8, strhash, strcompare);
	if (!tgt->params) {
		pr_error("Memory allocation failure\n");
		die();
	}

	if (no_params)
		return;

	for ( ; ; params = NULL) {
		char *argument;

		paramtoken = strtok_r(params, ",", &saveptr);
		if (paramtoken == NULL)
			break;

		argument = strchr(paramtoken, '=');
		if (argument) {
			*argument = '\0';
			argument++;
		}
		pr_verbose("option: '%s' argument: '%s'\n", paramtoken, argument);
		hashmapPut(tgt->params, paramtoken, argument);
	}
}

static int aboot_register_cmd(Hashmap *map, char *key, void *callback)
{
	char *k;

	k = xstrdup(key);
	if (hashmapGet(map, k)) {
		pr_error("key collision '%s'\n", k);
		free(k);
		return -1;
	}
	hashmapPut(map, k, callback);
	pr_verbose("Registered plugin function %p (%s) with table %p\n",
			callback, k, map);
	return 0;
}

int aboot_register_flash_cmd(char *key, flash_func callback)
{
	return aboot_register_cmd(flash_cmds, key, callback);
}

int aboot_register_oem_cmd(char *key, oem_func callback)
{
	return aboot_register_cmd(oem_cmds, key, callback);
}

/* Erase a named partition by creating a new empty partition on top of
 * its device node. No parameters. */
static void cmd_erase(char *part_name, int *fd, unsigned sz)
{
	struct fstab_rec *vol;

	if (is_loader_locked()) {
		fastboot_fail("LOCKED, unlock with 'fastboot oem unlock'");
		return;
	}

	vol = volume_for_name(part_name);
	if (vol == NULL) {
		fastboot_fail("unknown partition name");
		return;
	}

	pr_status("Erasing %s, this can take a while...\n", part_name);
	if (erase_partition(vol))
		fastboot_fail("Can't erase partition");
	else
		fastboot_okay("");

}

static int cmd_flash_ota_update(Hashmap *params, int *fd, unsigned sz)
{
	struct fstab_rec *cachevol;
	int action = !hashmapContainsKey(params, "noaction");
	int append = hashmapContainsKey(params, "append");
	void *data = NULL;

        cachevol = volume_for_path("/cache");
	if (!cachevol) {
		pr_error("Couldn't find cache partition. Is your recovery.fstab valid?\n");
		return -1;
	}
	if (mount_partition(cachevol)) {
		pr_error("Couldn't mount cache partition\n");
		return -1;
	}

	data = mmap64(NULL, sz, PROT_READ, MAP_SHARED, *fd, 0);
	if (data == (void*)-1){
		pr_error("Failed to mmap the file\n");
		return -1;
	}

	/* Once the update is applied this file is deleted */
	if (named_file_write("/mnt/cache/userfastboot.update.zip",
				data, sz, 0, append)) {
		pr_error("Couldn't write update package to cache partition.\n");
		unmount_partition(cachevol);
		munmap(data, sz);
		return -1;
	}
	unmount_partition(cachevol);
	munmap(data, sz);

	if (action) {
		apply_sw_update("/cache/userfastboot.update.zip", 1);
		return -1;
	}
	return 0;
}

/* Image command. Allows user to send a single file which
 * will be written to a destination location. Typical
 * usage is to write to a disk device node, in order to flash a raw
 * partition, but can be used to write any file.
 *
 * The parameter targetspec can be one of several possibilities:
 *
 * <name> : Look in the flash_cmds table and execute the callback function.
 *          If not found, lookup the named partition in recovery.fstab
 *          and write to its corresponding device node
 *
 * Targetspec may also specify a comma separated list of parameters
 * delimited from the target name by a colon. Each parameter is either
 * a simple string (for flags) or param=value.
 *
 */
static void cmd_flash(char *targetspec, int *fd, unsigned sz)
{
	struct flash_target tgt;
	flash_func cb;
	int ret;
        struct fstab_rec *vol;
	uint64_t vsize;

	void *data = NULL;
	uint32_t magic = 0;

	if (is_loader_locked()) {
		fastboot_fail("LOCKED, unlock with 'fastboot oem unlock'");
		return;
	}

	process_target(targetspec, &tgt);
	pr_verbose("data size %u\n", sz);

	pr_status("Flashing %s\n", targetspec);

	if ( (cb = hashmapGet(flash_cmds, tgt.name)) ) {
		/* Use our table of flash functions registered by platform
		 * specific plugin libraries */
		int cbret;
		cbret = cb(tgt.params, fd, sz);
		if (cbret) {
			pr_error("%s flash failed!\n", tgt.name);
			fastboot_fail("%s", tgt.name);
		} else
			fastboot_okay("");
		goto out;
	} else {
		vol = volume_for_name(tgt.name);
		if (!vol) {
			fastboot_fail("%s", tgt.name);
			goto out;
		}
	}

	data = mmap64(NULL, sz, PROT_READ, MAP_SHARED, *fd, 0);
	if (data == (void*)-1){
		pr_error("Failed to mmap the file\n");
		goto out_map;
	}

	if (!is_valid_blkdev(vol->blk_device)) {
		fastboot_fail("invalid destination node. partition disks?");
		goto out_map;
	}
	if (get_volume_size(vol, &vsize)) {
		fastboot_fail("couldn't get volume size");
		goto out_map;
	}

	if (!strcmp(targetspec, "fastboot") ||
	    !strcmp(targetspec, "recovery") ||
	    !strcmp(targetspec, "boot")) {
		if (bootimage_sanity_checks(data, sz)) {
			fastboot_fail("malformed AOSP boot image, refusing to flash!");
			goto out_map;
		}
	}

	if (!strcmp(targetspec, "bootloader")) {
		if (esp_sanity_checks(FASTBOOT_DOWNLOAD_TMP_FILE)) {
			fastboot_fail("malformed bootloader image");
			goto out_map;
		}
	}

	pr_debug("target '%s' volume size: %" PRIu64 " MiB\n", targetspec, vsize >> 20);

	if (sz >= sizeof(magic))
		memcpy(&magic, data, sizeof(magic));

	if (magic == SPARSE_HEADER_MAGIC) {
		/* If there is enough data to hold the header,
		 * and MAGIC appears in header,
		 * then it is a sparse ext4 image */
		struct sparse_header *sh = (struct sparse_header *)data;
		uint64_t totalsize = (uint64_t)sh->blk_sz * (uint64_t)sh->total_blks;
		pr_debug("Detected sparse header, total size %" PRIu64 " MiB\n",
				totalsize >> 20);
		if (totalsize > vsize) {
			fastboot_fail("target partition too small!");
			goto out_map;
		}
		ret = named_file_write_ext4_sparse(vol->blk_device, FASTBOOT_DOWNLOAD_TMP_FILE);
	} else {
		if (sz > vsize) {
			fastboot_fail("target partition too small!");
			goto out_map;
		}
		pr_debug("Writing %u MiB to %s\n", sz >> 20, vol->blk_device);
		ret = named_file_write(vol->blk_device, data, sz, 0, 0);
	}
	pr_verbose("Done writing image\n");
	if (ret) {
		fastboot_fail("Can't write data to target device");
		goto out_map;
	}
	sync();

	pr_debug("wrote %u bytes to %s\n", sz, vol->blk_device);

	fastboot_okay("");
out_map:
	ret = munmap(data, sz);
	if (ret)
		pr_error("Failed to munmap the file\n");
out:
	hashmapFree(tgt.params);
	if (*fd >= 0){
		close(*fd);
		unlink(FASTBOOT_DOWNLOAD_TMP_FILE);
	}
}

static void cmd_oem(char *arg, int *fd, unsigned sz)
{
	char *command, *saveptr, *str1;
	char *argv[MAX_OEM_ARGS];
	int argc = 0;
	oem_func cb;
	bool locked;

	pr_verbose("%s: <%s>\n", __FUNCTION__, arg);

	while (*arg == ' ')
		arg++;
	command = xstrdup(arg); /* Can't use strtok() on const strings */

	for (str1 = command; argc < MAX_OEM_ARGS; str1 = NULL) {
		argv[argc] = strtok_r(str1, " \t", &saveptr);
		if (!argv[argc])
			break;
		argc++;
	}
	if (argc == 0) {
		fastboot_fail("empty OEM command");
		goto out;
	}

	locked = is_loader_locked();

	if (!strcmp(argv[0], CMD_UNLOCK) || !strcmp(argv[0], CMD_UNLOCK_NOCONFIRM)) {
		if (locked) {
			if (set_loader_lock(false,
					!strcmp(argv[0], CMD_UNLOCK_NOCONFIRM))) {
				pr_error("Couldn't unlock!\n");
				fastboot_fail("oem unlock");
			} else {
				fastboot_okay("");
			}
		} else {
			fastboot_okay("already unlocked");
		}
		goto out;
	}

	if (locked) {
		fastboot_fail("LOCKED, unlock with 'fastboot oem unlock'");
		goto out;
	}

	if ( (cb = hashmapGet(oem_cmds, argv[0])) ) {
		int ret;

		ret = cb(argc, argv);
		if (ret) {
			pr_error("oem %s command failed, retval = %d\n",
					argv[0], ret);
			fastboot_fail("%s", argv[0]);
		} else
			fastboot_okay("");
	} else if (strcmp(argv[0], CMD_SHOWTEXT) == 0) {
		mui_show_text(1);
		fastboot_okay("");
	} else if (strcmp(argv[0], CMD_HIDETEXT) == 0) {
		mui_show_text(0);
		fastboot_okay("");
	} else if (strcmp(argv[0], CMD_LOCK) == 0) {
		set_loader_lock(true, false);
		fastboot_okay("");
	} else {
		fastboot_fail("unknown OEM command");
	}
out:
	if (command)
		free(command);
	return;
}

static void cmd_boot(char *arg, int *fd, unsigned sz)
{
	/* Copy the boot image to the ESP (bootloader partition)
	 * and set the BCB so that the loader knows to use it */
	struct fstab_rec *vol_bootloader, *vol_misc;
	struct bootloader_message bcb;
	int success = 0;
	void *data;

	if (is_loader_locked()) {
		fastboot_fail("LOCKED, unlock with 'fastboot oem unlock'");
		return;
	}

	pr_status("Preparing boot image\n");

	vol_bootloader = volume_for_name("bootloader");
	if (vol_bootloader == NULL) {
		pr_error("/bootloader not defined in fstab\n");
		fastboot_fail("can't find bootloader partition");
		return;
	}
	vol_misc = volume_for_name("misc");
	if (vol_misc == NULL) {
		pr_error("/misc not defined in fstab\n");
		fastboot_fail("can't find misc partition");
		return;
	}
	if (mount_partition(vol_bootloader)) {
		pr_error("Couldn't mount bootloader partition!\n");
		fastboot_fail("couldn't mount bootloader partition");
		return;
	}

	data = mmap64(NULL, sz, PROT_READ, MAP_SHARED, *fd, 0);
	if (data == (void*)-1){
		pr_error("Failed to mmap the file\n");
		goto out;
	}

	if (named_file_write("/mnt/bootloader/bootonce.img",
				data, sz, 0, 0)) {
		pr_error("Couldn't write boot image to bootloader partition.\n");
		goto out_unmap;
	}

	memset(&bcb, 0, sizeof(bcb));
	snprintf(bcb.command, sizeof(bcb.command), "bootonce-\\bootonce.img");
	if (named_file_write(vol_misc->blk_device, (void *)&bcb, sizeof(bcb), 0, 0)) {
		pr_error("Couldn't update BCB!\n");
		goto out_unmap;
	}
	success = 1;
out_unmap:
	munmap(data, sz);
out:
	unmount_partition(vol_bootloader);
	if (success) {
		pr_info("Booting into supplied image...\n");
		fastboot_okay("");
		android_reboot(ANDROID_RB_RESTART, 0, 0);
		pr_error("Reboot failed\n");
	}
}

static void cmd_reboot(char *arg, int *fd, unsigned sz)
{
	fastboot_okay("");
	sync();
	pr_info("Rebooting!\n");
	android_reboot(ANDROID_RB_RESTART, 0, 0);
	pr_error("Reboot failed\n");
}

static void cmd_reboot_bl(char *arg, int *fd, unsigned sz)
{
	fastboot_okay("");
	sync();
	pr_info("Restarting UserFastBoot...\n");
	android_reboot(ANDROID_RB_RESTART2, 0, "fastboot");
	pr_error("Reboot failed\n");
}

static int start_adbd(int argc, char **argv)
{
	return system("adbd &");
}

static void publish_from_prop(char *key, char *prop, char *dfl)
{
	char val[PROPERTY_VALUE_MAX];
	if (property_get(prop, val, dfl)) {
		char *valcpy = strdup(val);
		if (valcpy) {
			fastboot_publish(key, valcpy);
		}
	}
}


void populate_status_info(void)
{
	char *interface_info;
	char *infostring;

	pr_debug("updating status text\n");
	interface_info = get_network_interface_status();

	infostring = xasprintf("Userfastboot %s for %s\n \n"
		     "          kernel: %s\n"
		     "        firmware: %s\n"
		     "           board: %s\n"
		     "        serialno: %s\n"
		     "        unlocked: %s\n"
		     "   secure images: %s\n"
		     "     secure boot: %s\n"
		     " \n%s", USERFASTBOOT_VERSION,
		     fastboot_getvar("product"),
		     fastboot_getvar("kernel"),
		     fastboot_getvar("firmware"),
		     fastboot_getvar("board"),
		     fastboot_getvar("serialno"),
		     fastboot_getvar("unlocked"),
		     fastboot_getvar("secure"),
		     fastboot_getvar("secureboot"),
		     interface_info);
	pr_debug("%s", infostring);
	mui_infotext(infostring);
	free(infostring);
}


void aboot_register_commands(void)
{
	char *bios_vendor, *bios_version, *bios_string;
	char *board_vendor, *board_version, *board_name, *board_string;
	struct utsname uts;

	fastboot_register("oem", cmd_oem);
	fastboot_register("reboot", cmd_reboot);
	fastboot_register("reboot-bootloader", cmd_reboot_bl);
	fastboot_register("continue", cmd_reboot);

	fastboot_publish("product", DEVICE_NAME);
	fastboot_publish("product-name", get_dmi_data("product_name"));
	fastboot_publish("version-bootloader", USERFASTBOOT_VERSION);
	fastboot_publish("version-baseband", "N/A");
	publish_from_prop("serialno", "ro.serialno", "unknown");

	flash_cmds = hashmapCreate(8, strhash, strcompare);
	oem_cmds = hashmapCreate(8, strhash, strcompare);
	if (!flash_cmds || !oem_cmds) {
		pr_error("Memory allocation error\n");
		die();
	}
	publish_all_part_data();

	/* Currently we don't require signatures on images */
	fastboot_publish("secure", "no");

	fastboot_publish("secureboot", is_secure_boot_enabled() ? "yes" : "no");

	bios_vendor = get_dmi_data("bios_vendor");
	bios_version = get_dmi_data("bios_version");
	bios_string = xasprintf("%s %s", bios_vendor, bios_version);
	fastboot_publish("firmware", bios_string);
	free(bios_vendor);
	free(bios_version);

	board_vendor = get_dmi_data("board_vendor");
	board_version = get_dmi_data("board_version");
	board_name = get_dmi_data("board_name");
	board_string = xasprintf("%s %s %s", board_vendor, board_name, board_version);
	fastboot_publish("board", board_string);
	free(board_vendor);
	free(board_version);
	free(board_name);

	if (!uname(&uts))
		fastboot_publish("kernel", xasprintf("%s %s %s",
				uts.release, uts.version, uts.machine));
	else
		fastboot_publish("kernel", "unknown");


	/* At this time we don't have a special 'charge mode',
	 * which is entered when power is applied.
	 * if later we do, we need to implement a
	 * 'fastboot oem off-mode-charge 0' which bypasses
	 * charge mode and boots the device normally as
	 * if the user pressed the power button */
	fastboot_publish("off-mode-charge", "0");

	fastboot_register("boot", cmd_boot);
	fastboot_register("erase:", cmd_erase);
	fastboot_register("flash:", cmd_flash);
	aboot_register_flash_cmd("ota", cmd_flash_ota_update);
	aboot_register_flash_cmd("gpt", cmd_flash_gpt);
	aboot_register_oem_cmd("adbd", start_adbd);
	register_userfastboot_plugins();

	if (!is_loader_locked()) {
		fastboot_publish("unlocked", "yes");
	} else {
		fastboot_publish("unlocked", "no");
	}
}

/* vim: cindent:noexpandtab:softtabstop=8:shiftwidth=8:noshiftround
 */

